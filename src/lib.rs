//! # ZFUZZ
//!
//! Follow up on SFUZZ built on top of the unicorn emulation engine

#![feature(once_cell)]
#![feature(variant_count)]

pub mod syscalls;
pub mod pretty_printing;
pub mod mutator;
pub mod execution_state;
pub mod hooks;
pub mod arg_setup;
pub mod configurables;
pub mod grammar_mut;
pub mod targets {
    pub mod target_1;
    pub mod target_2;
    pub mod targets;
}

use crate::{
    execution_state::{ExecEnv, SnapshotContext, FileType, File},
    targets::targets::TARGET_INIT_FUNCTIONS,
    mutator::Mutator,
    grammar_mut::GrammarMut,
    arg_setup::OUTPUT_DIR,
    hooks::{
        insert_ld_st_boundcheck_hook,
        insert_dirty_page_tracking_hook,
        insert_coverage_hook,
    },
    configurables::{DEBUG, COVMAP_SIZE, SEED_ENERGY, FUZZ_INPUT, MUTATOR, MutType},
    targets::targets::HarnessInit,
};

use elfparser::{self, ARCH64, ELFMAGIC, LITTLEENDIAN};
use serde::{Deserialize, Serialize};
use rustc_hash::FxHashMap;
use parking_lot::RwLock;
use fasthash::{xx::Hash32, FastHash};
use unicorn_engine::{
    Unicorn, RegisterX86,
    unicorn_const::{Permission, uc_error, Arch},
};

use std::sync::atomic::AtomicUsize;
use std::collections::BTreeMap;
use std::sync::mpsc::Sender;
use std::cell::RefCell;
use std::sync::Arc;
use std::rc::Rc;
use std::process;

/// Small wrapper to easily handle unrecoverable errors without panicking
pub fn error_exit(msg: &str) -> ! {
    println!("{msg}");
    process::exit(1);
}

/// Small wrapper to easily handle debug prints
pub fn dbg_print(msg: &str) {
    if DEBUG {
        println!("[DEBUG]: {msg}");
    }
}

/// Thread-specific worker function that executes fuzz-cases, handles their return values, and
/// transmits statistics to the main function. This is where most of the interesting work happens
pub fn worker(harness_init: &HarnessInit, snapshot: Arc<SnapshotContext>, 
              all_shared: Arc<AllShared>, target_shared: Arc<TargetShared>, 
              tx: Sender<Statistics>) -> ! {

    // Create execution environment and unicorn engine
    let (exec_env, mut unicorn) = TARGET_INIT_FUNCTIONS[harness_init.target_id]()
                                    .expect("Failed to initialize one of the fuzz-targets");

    // These are allocations made during setup. These should only include regions such as the
    // stack, and argv regions and should thus never be free'd anyways
    exec_env.borrow_mut().heap_allocations = FxHashMap::default();

    // Insert required hooks
    {
        // Make sure this hook is placed before the dirty-page tracking hook, otherwise the other 
        // hook may segfault when attempting to read unmapped memory
        insert_ld_st_boundcheck_hook(&exec_env, &mut unicorn)
            .expect("Failed to insert dirty-page tracking hook");

        // This hook tracks dirtied pages. This is done so snapshots only reset state that was changed
        insert_dirty_page_tracking_hook(&exec_env, &mut unicorn)
            .expect("Failed to insert dirty-page tracking hook");

        // Grammar based fuzzing is currently still entirely generational and not mutational, so
        // only enable coverage tracking for mutational fuzzing
        if MUTATOR == MutType::Mut {
            insert_coverage_hook(&exec_env, &mut unicorn, &target_shared).unwrap();
        }
    }

    // Initialize the simple mutational mutator
    let mut mutator = Mutator::default();

    // Initialize the grammar generator
    let mut grammar_mutator = GrammarMut::default();

    // Locally count some statistics until they are eventually transmitted to main thread
    let mut local_total_crashes       = 0;
    let mut local_unique_crashes      = 0;
    let mut local_coverage_count      = 0;
    let mut local_invalid_insns_count = 0;

    // Current index into the input array of the corpus
    let mut input_index = 0;

    loop {
        // Chose an input from the queue to use for the next `SEED_ENERGY` cases
        input_index = (input_index + 1) % all_shared.inputs.read().len();

        for _ in 0..SEED_ENERGY {
            // Reset the emulator state
            let mut emu_ref = exec_env.borrow_mut();
            emu_ref.reset_snapshot(&mut unicorn, &snapshot).unwrap();

            // Reset the emulators current fuzz-input and fill it with data generated by one of the
            // mutators
            emu_ref.fuzz_input.clear();
            match MUTATOR {
                MutType::Gen => {
                    emu_ref.fuzz_input.extend_from_slice(&grammar_mutator.generate_input());
                    // Every 5 cases, add some random corruption to the input generated by the grammar
                    // mutator. This might uncover some weird edge-cases
                    if (SEED_ENERGY % 5) == 0 {
                        mutator.mutate(&mut emu_ref.fuzz_input);
                    }
                },
                MutType::Mut => {
                    emu_ref.fuzz_input.extend_from_slice(&all_shared.inputs.read()[input_index].data);
                    // Mutate the chosen seed
                    mutator.mutate(&mut emu_ref.fuzz_input);
                },
            }
            drop(emu_ref);

            // Run emulator and execute fuzz case until completion or a timeout is hit
            let mut case_res = unicorn.emu_start(
                unicorn.get_pc().unwrap(), 
                0, 
                harness_init.time_timeout, 
                harness_init.instr_timeout, 
                );

            // This means a syscall caused a crash so we overwrite the case-result with the fault
            // that occured during the syscall (since syscalls can't directly return errors, these
            // are communicated through the error_flag)
            if exec_env.borrow().error_flag != uc_error::OK {
                case_res = Err(exec_env.borrow().error_flag);
            }

            // If a crash occured, check if it is a unique crash (different pc from previous 
            // crashes), and if so, save the crashing input to disk
            if let Err(err) = case_res {
                let pc = unicorn.get_pc().unwrap() as usize;
                match err {
                    uc_error::INSN_INVALID => {
                        // Unicorn does not have great support for simd instruction sets
                        // There is nothing we can do about it, so we just tell the user so they can
                        // judge what percentage of their fuzz-cases is early-terminated from this
                        //
                        // We record this, but don't list it as a crash since it is an emulator 
                        // fault
                        let mut crash_map = target_shared.crash_mapping.write();
                        local_invalid_insns_count+=1;

                        if crash_map.get(&pc).is_some() {
                            continue;
                        }
                        crash_map.insert(pc, 0);

                        let output_dir = OUTPUT_DIR.get().unwrap();
                        let h = Hash32::hash(&exec_env.borrow().fuzz_input);
                        let target_dir = harness_init.target_id;
                        let out_file = format!("{output_dir}/{target_dir}/inv_insns/{h:x}_{pc:x}");
                        std::fs::write(&out_file, &exec_env.borrow().fuzz_input).unwrap();
                    },
                    uc_error::NOMEM           |
                    uc_error::READ_PROT       |
                    uc_error::READ_UNALIGNED  |
                    uc_error::READ_UNMAPPED   |
                    uc_error::WRITE_PROT      |
                    uc_error::WRITE_UNALIGNED |
                    uc_error::WRITE_UNMAPPED  |
                    uc_error::FETCH_PROT      |
                    uc_error::FETCH_UNALIGNED |
                    uc_error::FETCH_UNMAPPED  => {
                        let mut crash_map = target_shared.crash_mapping.write();
                        local_total_crashes += 1;

                        // This checks if this is is a unique crash or one we have seen before
                        if crash_map.get(&pc).is_some() {
                            continue;
                        }
                        local_unique_crashes += 1;
                        crash_map.insert(pc, 0);

                        let output_dir = OUTPUT_DIR.get().unwrap();
                        let h = Hash32::hash(&exec_env.borrow().fuzz_input);

                        let target_dir = harness_init.target_id;
                        let crash_file = match case_res {
                            Err(uc_error::READ_PROT)        |
                            Err(uc_error::READ_UNALIGNED)   |
                            Err(uc_error::READ_UNMAPPED) => {
                                format!("{output_dir}/{target_dir}/crashes/read_{h:x}_{pc:x}")
                            },
                            Err(uc_error::WRITE_PROT)        |
                            Err(uc_error::WRITE_UNALIGNED)   |
                            Err(uc_error::WRITE_UNMAPPED) => {
                                format!("{output_dir}/{target_dir}/crashes/write_{h:x}_{pc:x}")
                            },
                            Err(uc_error::FETCH_PROT)        |
                            Err(uc_error::FETCH_UNALIGNED)   |
                            Err(uc_error::FETCH_UNMAPPED) => {
                                format!("{output_dir}/{target_dir}/crashes/exec_{h:x}_{pc:x}")
                            },
                            Err(uc_error::NOMEM) => {
                                format!("{output_dir}/{target_dir}/crashes/oom_{h:x}_{pc:x}")
                            },
                            _ => unreachable!(),
                        };
                        std::fs::write(&crash_file, &exec_env.borrow().fuzz_input).unwrap();
                    },
                    _ => panic!("Emulator quit with unhandled error: {case_res:?} @ {pc:0x?}"),
                }
            }

            // Skip coverage checks if we are performing grammar-based generational fuzzing
            if MUTATOR == MutType::Gen {
                continue;
            }
            
            // Check if this case found new coverage, if so add it to corpus
            let case_cov = exec_env.borrow().cov_count;
            if case_cov > 0 {
                local_coverage_count += case_cov;
                let mut corp_inputs = all_shared.inputs.write();

                // Add this input to the corpus. Since the emulator no longer needs it (its being 
                // reset after this fuzz-case anyways), we just drain it out of the emulators 
                // fuzz_input instead of cloning a new data-array
                corp_inputs.push(Input::new(exec_env.borrow_mut().fuzz_input.drain(..).collect()));
            }
        }

        // Populate statistics that will be sent to the main thread
        let stats = Statistics {
            target_id:     harness_init.target_id,
            total_cases:   SEED_ENERGY,
            crashes:       local_total_crashes,
            ucrashes:      local_unique_crashes,
            coverage:      local_coverage_count,
            invalid_insns: local_invalid_insns_count,
            num_inputs:    all_shared.inputs.read().len(),
        };

        // Send stats over to the main thread
        tx.send(stats).expect("Failed to transmit stats from fuzz-thread");

        // Reset local statistics
        local_total_crashes       = 0;
        local_unique_crashes      = 0;
        local_coverage_count      = 0;
        local_invalid_insns_count = 0;
    }
}

/// Holds various information related to tracking statistics for the fuzzer
#[derive(Default, Clone, Copy, Deserialize, Serialize)]
pub struct Statistics {
    /// Indicator of which target provided this data to the main thread
    pub target_id: usize,

    /// Total number of fuzz cases
    pub total_cases: usize,

    /// Total crashes
    pub crashes: usize,

    /// Unique crashes (A crash at a pc that has not had a crash before)
    pub ucrashes: usize,

    /// Arbitrary number displaying coverage hit. Not 100% accurate when multi-threaded due to races
    /// and not very useful to compare against other fuzzers, but useful to evaluate progress during
    /// fuzzing campaign
    pub coverage: usize,

    /// Tracks how often unicorn runs into an instruction it can't handle (eg. avx-512 instructions)
    /// so we can tell the user if this is causing issues for the fuzz-runs
    pub invalid_insns: usize,

    /// Number of inputs currently being used for fuzzing
    pub num_inputs: usize,
}

impl Statistics {
    pub fn new(id: usize) -> Self {
        Self {
            target_id: id,
            total_cases: 0,
            crashes: 0,
            ucrashes: 0,
            coverage: 0,
            invalid_insns: 0,
            num_inputs: 0,
        }
    }
}

#[derive(Debug, Clone)]
/// In the future this could contain more information about the input used for power schedules
pub struct Input {
    /// Raw byte backing of this input
    data: Vec<u8>,
}

impl Input {
    pub fn new(data: Vec<u8>) -> Self {
        Self {
            data: data.to_vec(),
        }
    }
}

/// Tracks fuzz inputs
/// This is shared between ALL targets/threads since we assume that inputs are valid for all targets
/// being fuzzed together
#[derive(Debug)]
pub struct AllShared {
    /// Actual byte-backing for the fuzz-inputs
    pub inputs: RwLock<Vec<Input>>,
}

impl Default for AllShared {
    fn default() -> Self {
        Self::new()
    }
}

impl AllShared {
    /// Initialize a AllShared structure with default fields
    pub fn new() -> Self {
        Self {
            inputs: RwLock::new(Vec::new()),
        }
    }
}

/// Tracks variables that are shared between threads of a single target but not between targets
#[derive(Debug)]
pub struct TargetShared {
    /// Used to dedup crashes and only save off unique crashes
    pub crash_mapping: RwLock<FxHashMap<usize, u8>>,

    /// Fuzzer indexes this using a hash of the edge-coverage to check if it found new coverage
    pub coverage_bytemap: Vec<u8>,

    /// A coverage counter that is incremented whenever new coverage is found
    pub cov_counter: AtomicUsize,
}

impl Default for TargetShared {
    fn default() -> Self {
        Self::new()
    }
}

impl TargetShared {
    /// Initialize a TargetShared structure with default fields
    pub fn new() -> Self {
        Self {
            crash_mapping:    RwLock::new(FxHashMap::default()),
            coverage_bytemap: vec![0; COVMAP_SIZE as usize],
            cov_counter:      AtomicUsize::new(0),
        }
    }
}

/// Used to verify that the binary is suitable for this fuzzer. (64-bit, ELF, Little Endian...)
fn verify_elf_hdr(elf_hdr: elfparser::Header) -> Result<(), String> {
    if elf_hdr.magic != ELFMAGIC {
        return Err("Magic value does not match ELF".to_string());
    }
    if elf_hdr.endian != LITTLEENDIAN {
        return Err("Endian is not Little Endian".to_string());
    }
    if elf_hdr.bitsize != ARCH64 {
        return Err("Architecture is not 64-bit".to_string());
    }
    Ok(())
}

/// Parse out segments from an elf file and load them into emulator memory space
/// NOTE: This only works for statically linked elf binaries. For most other targets your best
/// bet will be to generate a memory dump and load that instead.
pub fn load_elf_segments(unicorn: &mut Unicorn<'_, ()>, filename: &str) -> Result<(), uc_error> {
    let target = std::fs::read(filename).expect("Failed to read target binary from disk");
    let elf = elfparser::ELF::parse_elf(&target);

    if let Err(error) = verify_elf_hdr(elf.header) {
        error_exit(&format!("Process exited with error: {error}"));
    }

    // Loop through all segments and allocate memory for each segment with segment-type=Load
    for phdr in elf.program_headers {
        if phdr.seg_type != elfparser::LOADSEGMENT {
            continue;
        }

        let mut data = target[phdr.offset..phdr.offset.checked_add(phdr.filesz).unwrap()].to_vec();

        // ELF files can contain padding that needs to be loaded into memory but does not exist
        // in the file on disk, we still need to fill it up in memory though
        data.extend_from_slice(&vec![0; phdr.memsz - phdr.filesz]);
        assert_eq!(data.len(), phdr.memsz, "Incorrect memory loading");

        // Unicorn requires 4kb alignment for address and size, so these masks are required
        let aligned_size = (phdr.align - 1 + phdr.memsz) & !(phdr.align - 1);
        let aligned_addr = (phdr.vaddr & !(phdr.align - 1)) as u64;
        assert!((aligned_size + aligned_addr as usize) >= (phdr.vaddr + phdr.memsz),
                "Aligning to memory bounds required by Unicorn messed up the allocation");

        // Convert elf permission flags to format Unicorn expects
        let perms: Permission = {
            let mut init_perms: Permission = Permission::NONE;
            if phdr.flags & 1 != 0 { init_perms |= Permission::EXEC;  }
            if phdr.flags & 2 != 0 { init_perms |= Permission::WRITE; }
            if phdr.flags & 4 != 0 { init_perms |= Permission::READ;  }
            init_perms
        };

        // Map data stored on disk for this section into emulator memory
        unicorn.mem_map(aligned_addr, aligned_size, perms).unwrap();

        // Write data for this section into emulator memory
        unicorn.mem_write(phdr.vaddr as u64, &data)?;

        assert_eq!(aligned_size % 4096, 0);
        assert_eq!(aligned_addr % 4096, 0);
    }

    unicorn.set_pc(elf.header.entry_addr as u64)?;
    Ok(())
}

/// Representation of a dumped file in a Rust structure so that Serde can deserialize it
#[derive(Debug, Deserialize)]
struct FileRepr { name: String,
    fd: usize,
    cursor: usize,
}

/// Representation of a dumped memory map in a Rust structure so that Serde can deserialize it
#[allow(unused)]
#[derive(Debug, Deserialize)]
struct MemMapRepr {
    start: u64,
    end: u64,
    size: usize,
    offset: usize,
    permissions: String,
    name: String,
}

/// Representation of a dumped register map in a Rust structure so that Serde can deserialize it
#[derive(Debug, Deserialize)]
pub struct RegRepr(BTreeMap<String, usize>);

/// Load a process dump from disk into unicorn. If your dump is different than the one generated
/// by `tools/snapshot.py` this function will need to be modified
pub fn load_dump(exec_env: &Rc<RefCell<ExecEnv>>, unicorn: &mut Unicorn<'_, ()>, dump_dir: &str) 
        -> Result<(), uc_error> {
    let files_path:      String = dump_dir.to_string() + "/files";
    let files_raw_path:  String = dump_dir.to_string() + "/raw_files/";
    let regs_path:       String = dump_dir.to_string() + "/regs";
    let memory_path:     String = dump_dir.to_string() + "/memory_maps";
    let raw_memory_path: String = dump_dir.to_string() + "/raw_memory/";

    // Load files from dump and initialize exec_env with the parsed file-data
    {
        let files_slice = std::fs::read(files_path).expect("Failed to read fd-dump");
        let open_files: Vec<FileRepr> =serde_json::from_slice(&files_slice).unwrap();

        for file in open_files {
            let file_fd = file.fd;
            // Determine the type of this file based on the fd number and the file-name
            let ftype: FileType = if file.name.contains(FUZZ_INPUT) {
                FileType::FUZZINPUT
            } else if file.name.contains("/dev/pts/") {
                match file.fd {
                    0 => FileType::STDIN,
                    1 => FileType::STDOUT,
                    2 => FileType::STDERR,
                    _ => unreachable!(),
                }
            } else {
                FileType::OTHER
            };

            // Read data that backs this file from dump files
            let backing: Option<Vec<u8>> = {
                if ftype == FileType::FUZZINPUT || file.fd == 0 || file.fd == 1 || file.fd == 2 {
                    Option::None
                } else {
                    Some(std::fs::read(files_raw_path.clone() + 
                                       &format!("raw_{file_fd}"))
                         .expect(&format!("Could not find data backing for file: {}", file.name)))
                }
            };

            // Initialize file in `exec_env` by either overwriting a default file or 
            // pushing a new file
            if file.fd >= exec_env.borrow().fd_list.len() {
                exec_env.borrow_mut().fd_list.push(File {
                    ftype,
                    backing,
                    cursor: Some(file.cursor),
                });
            } else {
                exec_env.borrow_mut().fd_list[file.fd] = File {
                    ftype,
                    backing,
                    cursor: Some(file.cursor),
                };
            }
        }
    }

    // Load memory from dump and initialize unicorn's memory mappings with the parsed memory-data
    // TODO: Check what the `offset` field is used for in gdb-memory-maps
    {
        let mem_slice = std::fs::read(memory_path).expect("Failed to read memory-mappings");
        let vmmap: Vec<MemMapRepr> = serde_json::from_slice(&mem_slice).unwrap();

        // Loop through all memory regions in the provided address space and map them into unicorn
        for (i, mem_region) in vmmap.iter().enumerate() {
            let data = std::fs::read(raw_memory_path.clone() + &format!("raw_{i}"))
                .expect(&format!("Failed to read raw memory for address range: {:#0x} - {:#0x}", 
                        mem_region.start, mem_region.end));

            // Unicorn requires 4kb alignment for address and size, so these masks are required
            let aligned_size: usize = (0x1000 - 1 + mem_region.size) & !(0x1000- 1);
            let aligned_addr: u64 = mem_region.start & !(0x1000- 1);
            assert!(aligned_size >= mem_region.size);
            assert!(aligned_addr <= mem_region.start);
            
            // Convert string-representation of permissions into `Permission` enum
            let perms: Permission = mem_region.permissions.chars().fold(Permission::NONE, 
                |cur, nxt| {
                    match nxt {
                        'r' => cur | Permission::READ,
                        'w' => cur | Permission::WRITE,
                        'x' => cur | Permission::EXEC,
                        _ => cur 
                    }
                });

            // Map data stored on disk for this section into emulator memory
            unicorn.mem_map(aligned_addr, aligned_size, perms).unwrap();

            // Write data for this section into emulator memory
            unicorn.mem_write(mem_region.start, &data).unwrap();

            assert_eq!(aligned_size % 4096, 0);
            assert_eq!(aligned_addr % 4096, 0);
        }
    }

    // Load registers from dump and initialize unicorn's registers with the parsed register-data
    {
        let reg_slice = std::fs::read(regs_path).expect("Failed to read register-mappings");
        let reg_mapping: RegRepr = serde_json::from_slice(&reg_slice).unwrap();

        match unicorn.get_arch() {
            Arch::X86 => resolve_x86_regs(unicorn, &reg_mapping)?,
            _ => panic!("Dump loader does not support your target arch\n\
            (Note: This is very easy to manually add, just requires you to define a \
            register-mapping dictionary"),
        }
    }

    Ok(())
}

/// Parse string representation of registers to unicorn `RegisterX86` enums
pub fn resolve_x86_regs(unicorn: &mut Unicorn<'_, ()>, reg_mappings: &RegRepr) 
        -> Result<(), uc_error> {
    unicorn.reg_write(RegisterX86::RAX, *reg_mappings.0.get("rax").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RBX, *reg_mappings.0.get("rbx").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RCX, *reg_mappings.0.get("rcx").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RDX, *reg_mappings.0.get("rdx").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RSI, *reg_mappings.0.get("rsi").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RDI, *reg_mappings.0.get("rdi").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RBP, *reg_mappings.0.get("rbp").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RSP, *reg_mappings.0.get("rsp").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R8, *reg_mappings.0.get("r8").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R9, *reg_mappings.0.get("r9").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R10, *reg_mappings.0.get("r10").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R11, *reg_mappings.0.get("r11").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R12, *reg_mappings.0.get("r12").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R13, *reg_mappings.0.get("r13").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R14, *reg_mappings.0.get("r14").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::R15, *reg_mappings.0.get("r15").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::RIP, *reg_mappings.0.get("rip").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::EFLAGS, *reg_mappings.0.get("eflags").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::CS, *reg_mappings.0.get("cs").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::SS, *reg_mappings.0.get("ss").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::DS, *reg_mappings.0.get("ds").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::ES, *reg_mappings.0.get("es").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::FS, *reg_mappings.0.get("fs").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::GS, *reg_mappings.0.get("gs").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::FS_BASE, *reg_mappings.0.get("fs_base").unwrap() as u64)?;
    unicorn.reg_write(RegisterX86::GS_BASE, *reg_mappings.0.get("gs_base").unwrap() as u64)?;
    Ok(())
}

